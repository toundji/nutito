"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedCommand = void 0;
const tslib_1 = require("tslib");
const yargs_1 = require("yargs");
const ora_1 = tslib_1.__importDefault(require("ora"));
const chalk_1 = require("chalk");
const connection_1 = require("../connection");
const useSeeders_1 = require("../useSeeders");
const fileHandling_1 = require("../utils/fileHandling");
const SeederImportationError_1 = require("../errors/SeederImportationError");
class SeedCommand {
    constructor() {
        this.command = 'seed';
        this.describe = 'Runs the seeds';
    }
    /**
     * @inheritdoc
     */
    builder(args) {
        return args
            .option('n', {
            alias: 'configName',
            type: 'string',
            describe: 'Name of the typeorm config file (json or js).',
        })
            .option('c', {
            alias: 'connection',
            type: 'string',
            default: 'default',
            describe: 'Name of the typeorm connection',
        })
            .option('r', {
            alias: 'root',
            type: 'string',
            describe: 'Path to your typeorm config file',
        })
            .option('s', {
            alias: 'seed',
            type: 'string',
            describe: 'Specific seed class to run.',
        });
    }
    /**
     * @inheritdoc
     */
    async handler(args) {
        const spinner = (0, ora_1.default)({ text: 'Loading ormconfig', isSilent: process.env.NODE_ENV === 'test' }).start();
        // Get TypeORM config file
        let options;
        try {
            (0, connection_1.configureConnection)({
                root: args.root,
                configName: args.configName,
                connection: args.connection,
            });
            options = await (0, connection_1.getConnectionOptions)();
            spinner.succeed('ORM Config loaded');
        }
        catch (error) {
            panic(spinner, error, 'Could not load the config file!');
            return;
        }
        // Show seeder in console
        spinner.start('Importing Seeder');
        let seeder;
        try {
            const seederFiles = (0, fileHandling_1.calculateFilePaths)(options.seeders);
            const seedersImported = await Promise.all(seederFiles.map((seederFile) => Promise.resolve().then(() => tslib_1.__importStar(require(seederFile)))));
            const allSeeders = seedersImported.reduce((prev, curr) => Object.assign(prev, curr), {});
            const seederWanted = args.seed || options.defaultSeeder;
            seeder = allSeeders[seederWanted];
            if (!seeder) {
                throw new SeederImportationError_1.SeederImportationError(`Seeder ${seederWanted} does not exist`);
            }
            spinner.succeed('Seeder imported');
        }
        catch (error) {
            panic(spinner, error, 'Could not import seeders!');
            return;
        }
        // Run seeder
        spinner.start(`Executing ${seeder.name} Seeder`);
        try {
            await (0, useSeeders_1.useSeeders)(seeder);
            spinner.succeed(`Seeder ${seeder.name} executed`);
        }
        catch (error) {
            panic(spinner, error, `Could not run the seed ${seeder.name}!`);
            return;
        }
        console.log('üëç ', chalk_1.gray.underline(`Finished Seeding`));
    }
}
exports.SeedCommand = SeedCommand;
function panic(spinner, error, message) {
    spinner.fail(message);
    console.error(error.message);
    (0, yargs_1.exit)(1, error);
}
//# sourceMappingURL=seed.command.js.map